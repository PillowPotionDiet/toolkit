/**
 * Script Generator for FTP Downloads
 * Generates PowerShell scripts for automated FTP downloads
 */

let generatedScript = '';
let currentSitesForScript = [];

/**
 * Generate PowerShell script for FTP downloads
 *
 * Hostinger FTP Structure:
 * - One main FTP account accesses all websites
 * - Each domain has its own folder inside public_html
 * - e.g., public_html/domain1.com/, public_html/domain2.com/
 * - Databases and emails are NOT accessible via FTP
 */
function generatePowerShellScript(ftpConfig, sites) {
  const { host, port, username, password, promptPassword } = ftpConfig;

  // For Hostinger, sites are in public_html/domain/ folders
  const sitePaths = sites.map(s => {
    // If path contains public_html, use as-is, otherwise construct the path
    const path = s.path && s.path.includes('public_html')
      ? s.path
      : `/public_html/${s.domain}`;
    return `    @{ Domain = "${s.domain}"; Path = "${path}" }`;
  }).join(",\n");

  const passwordSection = promptPassword
    ? `# Prompt for password securely
$ftpPass = Read-Host "Enter FTP Password for $ftpUser" -AsSecureString
$BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($ftpPass)
$ftpPassword = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)`
    : `$ftpPassword = "${password}"`;

  return `#####################################################################
# Website Migration - FTP Download Script
# Generated by Migration Assistant
# Date: ${new Date().toISOString().split('T')[0]}
#####################################################################
#
# HOSTINGER FTP STRUCTURE:
# - One FTP account accesses ALL websites
# - Each domain is in: public_html/domain.com/
# - Databases: Export manually via phpMyAdmin (not FTP)
# - Emails: Access via IMAP/webmail (not FTP)
#
#####################################################################

# FTP Configuration
$ftpHost = "${host}"
$ftpPort = ${port}
$ftpUser = "${username}"

${passwordSection}

# Output directory - creates a "migration-backups" folder on Desktop
$outputDir = Join-Path ([Environment]::GetFolderPath("Desktop")) "migration-backups"
if (-not (Test-Path $outputDir)) {
    New-Item -ItemType Directory -Path $outputDir -Force | Out-Null
}

Write-Host ""
Write-Host "======================================" -ForegroundColor Cyan
Write-Host " Website Migration FTP Downloader" -ForegroundColor Cyan
Write-Host "======================================" -ForegroundColor Cyan
Write-Host ""
Write-Host "FTP Host: $ftpHost" -ForegroundColor Gray
Write-Host "Username: $ftpUser" -ForegroundColor Gray
Write-Host "Output:   $outputDir" -ForegroundColor Gray
Write-Host ""
Write-Host "NOTE: This downloads website FILES only." -ForegroundColor Yellow
Write-Host "      Databases must be exported from phpMyAdmin." -ForegroundColor Yellow
Write-Host "      Emails must be backed up via IMAP/webmail." -ForegroundColor Yellow
Write-Host ""

# Sites to download (from public_html/{domain}/ folders)
$sites = @(
${sitePaths}
)

Write-Host "Sites to download: $($sites.Count)" -ForegroundColor Yellow
Write-Host ""

# Function to download directory recursively via FTP
function Download-FtpDirectory {
    param(
        [string]$ftpUrl,
        [string]$localPath,
        [string]$username,
        [string]$password
    )

    try {
        # Create local directory
        if (-not (Test-Path $localPath)) {
            New-Item -ItemType Directory -Path $localPath -Force | Out-Null
        }

        # List directory contents
        $listRequest = [System.Net.FtpWebRequest]::Create($ftpUrl)
        $listRequest.Method = [System.Net.WebRequestMethods+Ftp]::ListDirectoryDetails
        $listRequest.Credentials = New-Object System.Net.NetworkCredential($username, $password)
        $listRequest.UsePassive = $true
        $listRequest.UseBinary = $true
        $listRequest.KeepAlive = $false

        $response = $listRequest.GetResponse()
        $reader = New-Object System.IO.StreamReader($response.GetResponseStream())
        $listing = $reader.ReadToEnd()
        $reader.Close()
        $response.Close()

        # Parse directory listing
        $lines = $listing -split "\`r?\`n" | Where-Object { $_ -ne "" }

        foreach ($line in $lines) {
            # Parse FTP listing format (Unix style)
            if ($line -match '^([d-]).*\\s+(\\S+)$') {
                $isDir = $Matches[1] -eq 'd'
                $name = $Matches[2]

                # Skip . and ..
                if ($name -eq "." -or $name -eq "..") { continue }

                $remotePath = "$ftpUrl/$name"
                $localItemPath = Join-Path $localPath $name

                if ($isDir) {
                    Write-Host "  [DIR] $name" -ForegroundColor Blue
                    Download-FtpDirectory -ftpUrl $remotePath -localPath $localItemPath -username $username -password $password
                } else {
                    Write-Host "  [FILE] $name" -ForegroundColor Gray -NoNewline
                    try {
                        $downloadRequest = [System.Net.FtpWebRequest]::Create($remotePath)
                        $downloadRequest.Method = [System.Net.WebRequestMethods+Ftp]::DownloadFile
                        $downloadRequest.Credentials = New-Object System.Net.NetworkCredential($username, $password)
                        $downloadRequest.UsePassive = $true
                        $downloadRequest.UseBinary = $true

                        $downloadResponse = $downloadRequest.GetResponse()
                        $stream = $downloadResponse.GetResponseStream()
                        $file = [System.IO.File]::Create($localItemPath)
                        $stream.CopyTo($file)
                        $file.Close()
                        $stream.Close()
                        $downloadResponse.Close()

                        $size = (Get-Item $localItemPath).Length
                        Write-Host " ($([math]::Round($size/1KB, 1)) KB)" -ForegroundColor Green
                    } catch {
                        Write-Host " [FAILED]" -ForegroundColor Red
                    }
                }
            } else {
                # Alternative parsing for different FTP servers
                $parts = $line -split "\\s+" | Select-Object -Last 1
                if ($parts -and $parts -ne "." -and $parts -ne "..") {
                    $name = $parts
                    $remotePath = "$ftpUrl/$name"
                    $localItemPath = Join-Path $localPath $name

                    # Try to determine if it's a directory by trying to list it
                    try {
                        Write-Host "  [FILE] $name" -ForegroundColor Gray -NoNewline
                        $downloadRequest = [System.Net.FtpWebRequest]::Create($remotePath)
                        $downloadRequest.Method = [System.Net.WebRequestMethods+Ftp]::DownloadFile
                        $downloadRequest.Credentials = New-Object System.Net.NetworkCredential($username, $password)
                        $downloadRequest.UsePassive = $true
                        $downloadRequest.UseBinary = $true

                        $downloadResponse = $downloadRequest.GetResponse()
                        $stream = $downloadResponse.GetResponseStream()
                        $file = [System.IO.File]::Create($localItemPath)
                        $stream.CopyTo($file)
                        $file.Close()
                        $stream.Close()
                        $downloadResponse.Close()

                        $size = (Get-Item $localItemPath).Length
                        Write-Host " ($([math]::Round($size/1KB, 1)) KB)" -ForegroundColor Green
                    } catch {
                        # Might be a directory, try to recurse
                        Write-Host ""
                        Write-Host "  [DIR?] $name - attempting to list..." -ForegroundColor Blue
                        Download-FtpDirectory -ftpUrl $remotePath -localPath $localItemPath -username $username -password $password
                    }
                }
            }
        }
    } catch {
        Write-Host "Error accessing $ftpUrl : $_" -ForegroundColor Red
    }
}

# Alternative: Use WinSCP if available (more reliable)
function Test-WinSCP {
    $winscpPath = "C:\\Program Files (x86)\\WinSCP\\WinSCP.com"
    return Test-Path $winscpPath
}

# Download each site
$siteNum = 0
foreach ($site in $sites) {
    $siteNum++
    $domain = $site.Domain
    $remotePath = $site.Path

    Write-Host ""
    Write-Host "[$siteNum/$($sites.Count)] Downloading: $domain" -ForegroundColor Cyan
    Write-Host "Remote path: $remotePath" -ForegroundColor Gray

    $siteDir = Join-Path $outputDir $domain

    # Build FTP URL
    $ftpUrl = "ftp://$ftpHost" + ":$ftpPort" + $remotePath

    Write-Host "Connecting to: $ftpUrl" -ForegroundColor Gray

    try {
        Download-FtpDirectory -ftpUrl $ftpUrl -localPath $siteDir -username $ftpUser -password $ftpPassword
        Write-Host "Completed: $domain" -ForegroundColor Green
    } catch {
        Write-Host "Failed to download $domain : $_" -ForegroundColor Red
    }
}

Write-Host ""
Write-Host "======================================" -ForegroundColor Cyan
Write-Host " Download Complete!" -ForegroundColor Green
Write-Host "======================================" -ForegroundColor Cyan
Write-Host ""
Write-Host "Files saved to: $outputDir" -ForegroundColor Yellow
Write-Host ""
Write-Host "Press any key to open the download folder..."
$null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
Start-Process explorer.exe $outputDir
`;
}

/**
 * Generate a batch file wrapper for the PowerShell script
 */
function generateBatchWrapper(psScriptName) {
  return `@echo off
echo =============================================
echo  Website Migration - FTP Download Script
echo =============================================
echo.
echo This will download your websites via FTP.
echo Make sure you have the PowerShell script in the same folder.
echo.
pause
powershell -ExecutionPolicy Bypass -File "%~dp0${psScriptName}"
pause
`;
}

/**
 * Show script generator modal
 */
function showScriptGenerator() {
  // Get selected sites
  currentSitesForScript = Array.from(selectedSites).map(id => {
    const site = sites.find(s => s.id === id);
    return site ? { domain: site.domain, path: site.path || '/public_html' } : null;
  }).filter(Boolean);

  // Populate sites list
  document.getElementById('scriptSiteCount').textContent = currentSitesForScript.length;
  document.getElementById('scriptSitesList').innerHTML = currentSitesForScript
    .map(s => `<div style="padding: 0.25rem 0;">üìÅ ${s.domain} <span style="color: var(--text-tertiary);">(${s.path})</span></div>`)
    .join('');

  // Reset form
  document.getElementById('scriptPreviewSection').style.display = 'none';
  document.getElementById('downloadScriptBtn').style.display = 'none';
  document.getElementById('generateBtn').style.display = 'inline-flex';

  // Pre-fill FTP host if we have provider info
  const provider = Utils.getStorage('migration_provider') || {};
  if (provider.ftp?.host) {
    document.getElementById('scriptFtpHost').value = provider.ftp.host;
  }
  if (provider.ftp?.username) {
    document.getElementById('scriptFtpUser').value = provider.ftp.username;
  }

  // Setup password option toggle
  document.querySelectorAll('input[name="passwordOption"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
      document.getElementById('passwordInputGroup').style.display =
        e.target.value === 'include' ? 'block' : 'none';
    });
  });

  // Show modal
  document.getElementById('downloadChecklistModal').classList.add('hidden');
  document.getElementById('scriptGeneratorModal').classList.remove('hidden');
}

/**
 * Close script generator modal
 */
function closeScriptGenerator() {
  document.getElementById('scriptGeneratorModal').classList.add('hidden');
  document.getElementById('downloadChecklistModal').classList.remove('hidden');
}

/**
 * Generate the script based on form input
 */
function generateScript() {
  const host = document.getElementById('scriptFtpHost').value.trim();
  const port = parseInt(document.getElementById('scriptFtpPort').value) || 21;
  const username = document.getElementById('scriptFtpUser').value.trim();
  const promptPassword = document.querySelector('input[name="passwordOption"]:checked').value === 'prompt';
  const password = document.getElementById('scriptFtpPass').value;

  if (!host || !username) {
    Utils.showAlert('Please enter FTP Host and Username.', 'warning');
    return;
  }

  if (!promptPassword && !password) {
    Utils.showAlert('Please enter password or select "Prompt at runtime".', 'warning');
    return;
  }

  // Save FTP info for later
  const provider = Utils.getStorage('migration_provider') || {};
  provider.ftp = { host, username, port };
  Utils.setStorage('migration_provider', provider);

  // Generate script
  generatedScript = generatePowerShellScript({
    host,
    port,
    username,
    password: promptPassword ? '' : password,
    promptPassword
  }, currentSitesForScript);

  // Show preview
  document.getElementById('scriptPreview').textContent = generatedScript;
  document.getElementById('scriptPreviewSection').style.display = 'block';
  document.getElementById('downloadScriptBtn').style.display = 'inline-flex';
  document.getElementById('generateBtn').style.display = 'none';

  // Scroll to preview
  document.getElementById('scriptPreviewSection').scrollIntoView({ behavior: 'smooth' });
}

/**
 * Copy script to clipboard
 */
function copyScriptToClipboard() {
  navigator.clipboard.writeText(generatedScript).then(() => {
    const btn = document.getElementById('copyScriptBtn');
    const originalText = btn.innerHTML;
    btn.innerHTML = '‚úì Copied!';
    btn.style.background = 'var(--success-color)';
    btn.style.color = 'white';
    setTimeout(() => {
      btn.innerHTML = originalText;
      btn.style.background = '';
      btn.style.color = '';
    }, 2000);
  }).catch(err => {
    Utils.showAlert('Failed to copy: ' + err.message, 'error');
  });
}

/**
 * Download script as .ps1 file
 */
function downloadScript() {
  const blob = new Blob([generatedScript], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'migration-download.ps1';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);

  // Also offer batch file
  setTimeout(() => {
    if (confirm('Would you also like to download a .bat file to easily run the script?')) {
      const batchContent = generateBatchWrapper('migration-download.ps1');
      const batchBlob = new Blob([batchContent], { type: 'text/plain' });
      const batchUrl = URL.createObjectURL(batchBlob);
      const batchA = document.createElement('a');
      batchA.href = batchUrl;
      batchA.download = 'run-migration.bat';
      document.body.appendChild(batchA);
      batchA.click();
      document.body.removeChild(batchA);
      URL.revokeObjectURL(batchUrl);
    }
  }, 500);

  Utils.showAlert('Script downloaded! Run it with PowerShell on your computer.', 'success');
}
